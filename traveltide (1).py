# -*- coding: utf-8 -*-
"""TravelTide.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pgEH5w__2gfmHdZhIWgEVMwQ3o4Lo284

###Connection

Import the needed libraries
"""

import pandas as pd
import sqlalchemy as sa

"""Create a variable with the link to the database"""

traveltide_database = "postgresql://Test:bQNxVzJL4g6u@ep-noisy-flower-846766.us-east-2.aws.neon.tech/TravelTide"

"""Initialize the database engine and connect to the database"""

engine = sa.create_engine(traveltide_database)
connection = engine.connect().execution_options(isolation_level = "AUTOCOMMIT")

"""Create an inspector object for the database"""

inspector = sa.inspect(engine)

""" Get the names of tyhe tables"""

table_names = inspector.get_table_names()
table_names

"""### EDA

####Understanding the Data Structure
To understand the data structure, we should start by querying the number of rows in each table and examining the data types of the columns.

Get the number of rows in each table

Query to Get the Size of Each Table
"""

query="""
SELECT 'users' AS table_name, COUNT(*) AS row_count FROM users
UNION ALL
SELECT 'sessions' AS table_name, COUNT(*) AS row_count FROM sessions
UNION ALL
SELECT 'flights' AS table_name, COUNT(*) AS row_count FROM flights
UNION ALL
SELECT 'hotels' AS table_name, COUNT(*) AS row_count FROM hotels;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""#### Initial Data Quality Check
Perform initial checks to ensure data integrity. This includes checking for null values and examining unique values in categorical columns.

Check for null values in each column of the users table
"""

query="""
SELECT
    SUM(CASE WHEN user_id IS NULL THEN 1 ELSE 0 END) AS user_id_nulls,
    SUM(CASE WHEN birthdate IS NULL THEN 1 ELSE 0 END) AS birthdate_nulls,
    SUM(CASE WHEN gender IS NULL THEN 1 ELSE 0 END) AS gender_nulls,
    SUM(CASE WHEN married IS NULL THEN 1 ELSE 0 END) AS married_nulls,
    SUM(CASE WHEN has_children IS NULL THEN 1 ELSE 0 END) AS has_children_nulls,
    SUM(CASE WHEN home_country IS NULL THEN 1 ELSE 0 END) AS home_country_nulls,
    SUM(CASE WHEN home_city IS NULL THEN 1 ELSE 0 END) AS home_city_nulls,
    SUM(CASE WHEN home_airport IS NULL THEN 1 ELSE 0 END) AS home_airport_nulls,
    SUM(CASE WHEN home_airport_lat IS NULL THEN 1 ELSE 0 END) AS home_airport_lat_nulls,
    SUM(CASE WHEN home_airport_lon IS NULL THEN 1 ELSE 0 END) AS home_airport_lon_nulls,
    SUM(CASE WHEN sign_up_date IS NULL THEN 1 ELSE 0 END) AS sign_up_date_nulls

FROM users;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""Get unique values in the gender column , Breakdown of users by gender

Query to Examine Unique Values in Categorical Columns:
"""

query="""
SELECT gender, COUNT(*) AS user_count
FROM users
GROUP BY gender
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""####Descriptive Analysis
Start by understanding the basic demographics of our user base and continue with descriptive statistics for hotel and flight bookings.

Query to Get Breakdown of Users by Gender, Marital Status, and Whether They Have Children:
"""

query = """
-- Get unique values in the hotel_name column, split by '-'
SELECT DISTINCT SPLIT_PART(hotel_name, '-', 1) AS brand_hotel_name,
                SPLIT_PART(hotel_name, '-', 2) AS hotel_name
FROM hotels
LIMIT 1000;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query), connection))

"""Breakdown by marital status"""

query="""
SELECT married, COUNT(*) AS user_count
FROM users
GROUP BY married;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""Breakdown by whether users have children"""

query="""
SELECT has_children, COUNT(*) AS user_count
FROM users
GROUP BY has_children;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""Extract the year from birthdate and count occurrences"""

query="""
SELECT CAST(EXTRACT(YEAR FROM birthdate) AS INT) AS birth_year, COUNT(*) AS user_count
FROM users
GROUP BY CAST(EXTRACT(YEAR FROM birthdate) AS INT)
ORDER BY CAST(EXTRACT(YEAR FROM birthdate) AS INT);
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

query="""SELECT
MAX(CAST(EXTRACT(YEAR FROM birthdate) AS INT)) AS MAX_birth_year,
MIN(CAST(EXTRACT(YEAR FROM birthdate) AS INT)) AS MIN_birth_year
FROM users
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

query = """
SELECT CAST(PERCENTILE_CONT(0.5) WITHIN GROUP (
    ORDER BY EXTRACT(YEAR FROM AGE(CURRENT_DATE, sign_up_date)) * 12 +
             EXTRACT(MONTH FROM AGE(CURRENT_DATE, sign_up_date)) +
             EXTRACT(DAY FROM AGE(CURRENT_DATE, sign_up_date)) / 30.0
) AS INT) AS median_customer_age_in_months
FROM users;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query), connection))

""" 10 most popular hotels based on booking count"""

query = """
SELECT
    COUNT(*) AS total_bookings,
    ROUND(AVG(nights), 2) AS avg_nights_stayed,
    ROUND(AVG(hotel_per_room_usd), 2) AS avg_price_per_night_usd
FROM
    hotels h
LEFT JOIN
    sessions s ON h.trip_id = s.trip_id
WHERE
   hotel_booked = 'true'
GROUP BY
    hotel_name
ORDER BY
    total_bookings DESC
LIMIT
    10;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query), connection))

"""10 most expensive hotels by average price per night"""

query="""
SELECT hotel_name,
       AVG(hotel_per_room_usd) AS avg_price_per_night,
       ROUND(AVG(nights),0) AS avg_nights_stayed
FROM hotels
GROUP BY hotel_name
ORDER BY avg_price_per_night DESC
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

query = """
SELECT
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY hotel_per_room_usd) AS median_price_per_night,
    AVG(hotel_per_room_usd) AS avg_price_per_night,
    AVG(nights) AS avg_nights_stayed
FROM
    hotels;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query), connection))

"""Query to Get the most used airline in the last 6 months"""

query = """
WITH RecentSessions AS (
    SELECT trip_id, MAX(session_end) AS last_session_end
    FROM sessions
    GROUP BY trip_id
)
SELECT f.trip_airline, COUNT(*) AS flight_count
FROM flights f
JOIN RecentSessions rs ON f.trip_id = rs.trip_id
WHERE f.departure_time >= rs.last_session_end - INTERVAL '6 months'
GROUP BY f.trip_airline
ORDER BY flight_count DESC
LIMIT 5;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query), connection))

"""Query to Get the Average Number of Seats Booked on Flights:"""

query = """
SELECT ROUND(AVG(seats), 0) AS avg_seats_booked
FROM flights;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query), connection))

"""Get the median number of seats booked on flights"""

query = """
SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY seats) AS median_seats_booked
FROM flights;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query), connection))

"""Joining users and sessions tables"""

query="""
SELECT
  u.user_id, u.birthdate, u.gender, u.home_country, u.home_city,
  s.session_id, s.trip_id, s.session_start, s.flight_discount, s.hotel_discount, s.flight_booked, s.hotel_booked
FROM users u
JOIN sessions s ON u.user_id = s.user_id;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""####Session-Level Insights

Understand the session behaviors such as duration, number of clicks, and the presence of bookings.
"""

query="""
WITH user_bookings AS (
    SELECT user_id,
           SUM(CASE WHEN flight_booked ='true' THEN 1 ELSE 0 END) AS total_flight_bookings, -- Count bookings as 1, non-bookings as 0
           SUM(CASE WHEN hotel_booked ='true' THEN 1 ELSE 0 END) AS total_hotel_bookings  -- Count bookings as 1, non-bookings as 0
    FROM sessions
    WHERE cancellation ='false'
    GROUP BY user_id
),
avg_session_duration AS (
    SELECT user_id,
           AVG(((session_end - session_start)) / 60) AS avg_session_duration_minutes
    FROM sessions
    GROUP BY user_id
)
SELECT u.user_id,
       total_flight_bookings,
       total_hotel_bookings,
       (total_flight_bookings + total_hotel_bookings) AS total_bookings,
       avg_session_duration_minutes
FROM users u
JOIN user_bookings b ON u.user_id = b.user_id
JOIN avg_session_duration s ON u.user_id = s.user_id; -- Join with the average session duration CTE
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

query2 = """
WITH avg_session_duration AS (
    SELECT user_id,
           ROUND(AVG(EXTRACT(EPOCH FROM (session_end - session_start)) / 60), 2) AS avg_session_duration_minutes  -- Convert duration to minutes
    FROM sessions
    GROUP BY user_id
)
SELECT u.user_id,
       s.avg_session_duration_minutes
FROM users u
JOIN avg_session_duration s ON u.user_id = s.user_id;
"""
print('Result Query 2:')
display(pd.read_sql(sa.text(query2), connection))

"""Feature Engineering
Now that we understand the data,we will create meaningful features that can be used to segment customers.

####Create New Features

we may want to create new columns that summarize a user's interaction with TravelTide.
Calculate total number of bookings per user
"""

query="""
WITH user_bookings AS (
    SELECT user_id,
           SUM(CASE WHEN cancellation ='true'THEN 1 ELSE 0 END)AS cancellation_bookings, -- Count bookings as 1, non-bookings as 0
           SUM(CASE WHEN flight_booked ='true' THEN 1 ELSE 0 END) AS total_flight_bookings, -- Count bookings as 1, non-bookings as 0
           SUM(CASE WHEN hotel_booked ='true' THEN 1 ELSE 0 END) AS total_hotel_bookings  -- Count bookings as 1, non-bookings as 0
    FROM sessions
    WHERE cancellation ='false'
    GROUP BY user_id
)
SELECT u.user_id,
       cancellation_bookings,
       total_flight_bookings,
       total_hotel_bookings,
       (total_flight_bookings + total_hotel_bookings) AS total_bookings
FROM users u
JOIN user_bookings b ON u.user_id = b.user_id;
"""
print('Result Query 1:')
display(pd.read_sql(sa.text(query),connection))

"""###segmentation

####Segment Customers Based on Total Bookings
This SQL query calculates the total number of flight and hotel bookings for each user and then segments these users into three categories based on their total bookings: High, Medium, and Low. The segmentation is defined as follows:

High: Users with 10 or more total bookings.
Medium: Users with 5 to 9 total bookings.
Low: Users with fewer than 5 total bookings.
"""

querey="""
-- Calculate total bookings and segment customers
WITH user_bookings AS (
    SELECT user_id,
           SUM(CASE WHEN flight_booked='true' THEN 1 ELSE 0 END) AS total_flight_bookings,
           SUM(CASE WHEN hotel_booked ='true' THEN 1 ELSE 0 END) AS total_hotel_bookings
    FROM sessions
    WHERE cancellation = 'false'
    GROUP BY user_id
),
booking_summary AS (
    SELECT u.user_id,
           (total_flight_bookings + total_hotel_bookings) AS total_bookings
    FROM users u
    JOIN user_bookings b ON u.user_id = b.user_id
)
SELECT user_id,
       CASE
           WHEN total_bookings >= 10 THEN 'High'
           WHEN total_bookings BETWEEN 5 AND 9 THEN 'Medium'
           ELSE 'Low'
       END AS booking_segment
FROM booking_summary;
"""
print('Result Query :')
# Use the defined variable 'querey' instead of 'query'
display(pd.read_sql(sa.text(querey),connection))

"""####Identify Perk Preferences
This SQL query determines each user's preferred perk based on their session activity. The perks evaluated are Free Cancellation, Flight Discount, and Hotel Discount. The query identifies which perk each user prefers by comparing the frequency of their interactions with each type of perk.


"""

query="""
WITH perks_summary AS (
    SELECT
        user_id,
        SUM(CASE WHEN cancellation = 'true' THEN 1
            ELSE 0
            END) AS cancellation_pref,
        SUM(CASE WHEN flight_discount = 'true' AND cancellation = 'false' AND flight_booked = 'true' THEN 1
            ELSE 0
            END) AS flight_discount_pref,
        SUM(CASE WHEN hotel_discount = 'true' AND cancellation = 'false' AND hotel_booked = 'true' THEN 1
            ELSE 0
            END) AS hotel_discount_pref,
        SUM(CASE WHEN flight_booked = 'true' THEN 1 ELSE 0 END) as total_flight_booked,
        SUM(CASE WHEN hotel_booked = 'true' THEN 1 ELSE 0 END) as total_hotel_booked -- Add count of flight and hotel bookings here
    FROM sessions
    GROUP BY user_id
)
SELECT
    user_id,
    cancellation_pref,
    CASE
        WHEN (cancellation_pref <= 3) AND (total_flight_booked + total_hotel_booked > 3) THEN 'Free Cancellation'
        WHEN flight_discount_pref > hotel_discount_pref THEN 'Flight Discount'
        ELSE 'Hotel Discount'
    END AS preferred_perk
FROM perks_summary
order by cancellation_pref desc

;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""#### Recency, Frequency, Monetary (RFM) Analysis
RFM analysis is a classic method for customer segmentation, especially in marketing. It evaluates customers based on three factors:

Recency: How recently did the customer make a booking?
Frequency: How often does the customer make bookings?
Monetary: How much money does the customer spend on bookings?

Calculate Recency, Frequency, and Monetary value for each user
"""

query="""
WITH rfm AS (
    SELECT
        s.user_id,
        MAX(DATE(s.session_end)) AS last_booking_date,  -- Recency: Date of the most recent session
        COUNT(s.session_id) AS frequency,               -- Frequency: Total number of sessions
        SUM(COALESCE(f.base_fare_usd, 0) + COALESCE(h.hotel_per_room_usd, 0)) AS monetary -- Monetary: Sum of all spending
    FROM sessions s
    LEFT JOIN flights f ON s.trip_id = f.trip_id
    LEFT JOIN hotels h ON s.trip_id = h.trip_id
    GROUP BY s.user_id
)
SELECT
    rfm.user_id,
    MAX(DATE(s.session_end)) - rfm.last_booking_date AS recency_days,  -- Calculate recency in days
    rfm.frequency,
    rfm.monetary
FROM rfm
JOIN sessions s ON rfm.user_id = s.user_id
GROUP BY rfm.user_id, rfm.last_booking_date, rfm.frequency, rfm.monetary;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""####RFM Categorization:

We can then categorize customers into segments such as High Value, Loyal Customers, At-Risk Customers, etc., based on the RFM scores.

#### Lifetime Value (LTV)
Estimate the lifetime value of a customer by projecting future spending based on past behavior. This can be useful in identifying Our most valuable customers.

Calculate LTV by estimating future spending based on average spend and frequency
"""

querey="""
WITH ltv AS (
    SELECT
        user_id,
        AVG(base_fare_usd + hotel_per_room_usd) AS avg_spend_per_booking, -- Average spending per booking
        COUNT(session_id) AS booking_frequency
    FROM sessions s
    LEFT JOIN flights f ON s.trip_id = f.trip_id
    LEFT JOIN hotels h ON s.trip_id = h.trip_id
    GROUP BY user_id
)
SELECT
    user_id,
    (avg_spend_per_booking * booking_frequency) AS estimated_lifetime_value
FROM ltv;
"""
print('Result Query :')
# Use the defined variable 'querey' instead of 'query'
display(pd.read_sql(sa.text(querey),connection))

"""#### Behavioral Segmentation
Segment customers based on their interaction with the platform, such as:

Booking Behavior: Flight-only bookers, Hotel-only bookers, Both.
Cancellation Behavior: Frequent cancellers vs. non-cancellers.
Discount Sensitivity: Customers who frequently book with discounts vs. those who don’t.

Segment users based on booking behavior
"""

querey="""
WITH booking_behavior AS (
    SELECT
        user_id,
        SUM(CASE WHEN flight_booked ='true' THEN 1 ELSE 0 END) AS flight_bookings,  -- Count flight bookings
        SUM(CASE WHEN hotel_booked ='true' THEN 1 ELSE 0 END) AS hotel_bookings   -- Count hotel bookings
    FROM sessions
    GROUP BY user_id
)
SELECT
    user_id,
    CASE
        WHEN flight_bookings > 0 AND hotel_bookings = 0 THEN 'Flight-only Booker'
        WHEN flight_bookings = 0 AND hotel_bookings > 0 THEN 'Hotel-only Booker'
        WHEN flight_bookings > 0 AND hotel_bookings > 0 THEN 'Both'
        ELSE 'No Bookings'
    END AS booking_behavior_segment
FROM booking_behavior;
"""
print('Result Query :')
# Use the defined variable 'querey' instead of 'query'
display(pd.read_sql(sa.text(querey),connection))

"""#### Seasonality and Timing
Segment customers based on when they typically book (e.g., high season vs. low season, weekdays vs. weekends).

Segment users based on the season they typically book
"""

query = """
WITH booking_season AS (
    SELECT
        s.user_id,
        EXTRACT(MONTH FROM f.departure_time) AS booking_month
    FROM flights f
    JOIN sessions s ON f.trip_id = s.trip_id
    WHERE f.departure_time IS NOT NULL
)
SELECT
    user_id,
    CASE
        WHEN booking_month IN (12, 1, 2) THEN 'Winter'
        WHEN booking_month IN (3, 4, 5) THEN 'Spring'
        WHEN booking_month IN (6, 7, 8) THEN 'Summer'
        WHEN booking_month IN (9, 10, 11) THEN 'Autumn'
        ELSE 'Unknown'
    END AS booking_season
FROM booking_season;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query), connection))

"""#### Churn Risk Segmentation
Identify customers who are at risk of churning (leaving the platform) based on their inactivity or other factors.

Segment users based on the risk of churn (e.g., no bookings in the last 6 months)
"""

query=""" WITH churn_risk AS (
    SELECT
        user_id,
        MAX(session_end) AS last_session_date
    FROM sessions
    GROUP BY user_id
)
SELECT
    user_id,
    CASE
        WHEN EXTRACT(DAY FROM
            (CURRENT_DATE - last_session_date)) > 180 THEN 'High Churn Risk'
        ELSE 'Low Churn Risk'
    END AS churn_risk_segment
FROM churn_risk;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""#### Loyalty Segmentation
Identify the most loyal customers based on metrics like the number of repeat bookings or the length of time they’ve been a customer.
"""

query = """
WITH loyalty AS (
    SELECT
        u.user_id,
        COUNT(s.session_id) AS repeat_bookings,
        (CURRENT_DATE - u.sign_up_date) AS days_since_signup
    FROM sessions s
    JOIN users u ON s.user_id = u.user_id
    GROUP BY u.user_id
)
SELECT
    user_id,
    CASE
        WHEN repeat_bookings > 10 AND days_since_signup > 365 THEN 'High Loyalty'
        WHEN repeat_bookings BETWEEN 5 AND 10 THEN 'Medium Loyalty'
        ELSE 'Low Loyalty'
    END AS loyalty_segment
FROM loyalty;
"""
print('Result Query:')
display(pd.read_sql(sa.text(query), connection))

"""#### Customer Value Segmentation
Classify customers into tiers based on their spending or contribution to revenue.

Segment users into value tiers based on their total spending
"""

query="""
WITH customer_value AS (
    SELECT
        user_id,
        SUM(base_fare_usd + hotel_per_room_usd) AS total_spent
    FROM sessions s
    LEFT JOIN flights f ON s.trip_id = f.trip_id
    LEFT JOIN hotels h ON s.trip_id = h.trip_id
    GROUP BY user_id
)
SELECT
    user_id,
    CASE
        WHEN total_spent > 10000 THEN 'Platinum'
        WHEN total_spent BETWEEN 5000 AND 9999 THEN 'Gold'
        WHEN total_spent BETWEEN 1000 AND 4999 THEN 'Silver'
        ELSE 'Bronze'
    END AS value_segment
FROM customer_value;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""#### Promotion Sensitivity
Identify customers who are more responsive to promotions or discounts.

Segment users based on their sensitivity to promotions (e.g., those who booked more often with discounts)
"""

query = """
WITH promo_sensitivity AS (
    SELECT
        user_id,
        SUM(CASE WHEN flight_discount = TRUE OR hotel_discount = TRUE THEN 1 ELSE 0 END) AS discounted_bookings,
        COUNT(session_id) AS total_sessions
    FROM sessions
    GROUP BY user_id
)
SELECT
    user_id,
    CASE
        WHEN (discounted_bookings::float / total_sessions) >= 0.5 THEN 'Promotion Sensitive'
        ELSE 'Not Promotion Sensitive'
    END AS promo_segment
FROM promo_sensitivity;
"""
print('Result Query:')
display(pd.read_sql(sa.text(query), connection))

"""#### Booking Window Segmentation
Segment customers based on how far in advance they book their travel plans.

Segment users based on how far in advance they book (e.g., last-minute vs. early planners)
"""

query="""
WITH booking_window AS (
    SELECT
        user_id,
        AVG(EXTRACT(DAY FROM departure_time - session_start)) AS avg_booking_window_days -- Use EXTRACT to get the difference in days
    FROM flights f
    JOIN sessions s ON f.trip_id = s.trip_id
    GROUP BY user_id
)
SELECT
    user_id,
    CASE
        WHEN avg_booking_window_days <= 7 THEN 'Last-Minute Bookers'
        WHEN avg_booking_window_days BETWEEN 8 AND 30 THEN 'Moderate Planners'
        ELSE 'Early Planners'
    END AS booking_window_segment
FROM booking_window;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""To implement a comprehensive segmentation strategy for TravelTide, I'll mix and match the suggested segmentation techniques. The goal is to create a detailed and nuanced customer view that can guide marketing efforts, improve retention, and enhance overall service.

### Data Preparation
First, let's assume the necessary tables (users, sessions, flights, hotels) are already available. We will clean and join these tables to create a master dataset that includes key metrics for each customer.
"""

query = """
WITH master_data AS (
    SELECT
        u.user_id,
        u.sign_up_date,
        u.home_country,
        u.home_airport_lat,
        u.home_airport_lon,
        COUNT(s.session_id) AS total_sessions,
        SUM(f.base_fare_usd + COALESCE(h.hotel_per_room_usd, 0)) AS total_spent,
        MAX(s.session_end) AS last_session_date,
        MIN(f.departure_time) AS first_booking_date,
        COUNT(DISTINCT f.trip_id) AS total_flight_bookings,
        COUNT(DISTINCT h.trip_id) AS total_hotel_bookings,
        AVG(CAST(f.departure_time AS DATE) - CAST(s.session_start AS DATE)) AS avg_booking_window_days,
        SUM(CASE WHEN s.flight_discount = TRUE OR s.hotel_discount = TRUE THEN 1 ELSE 0 END) AS discounted_bookings
    FROM users u
    LEFT JOIN sessions s ON u.user_id = s.user_id
    LEFT JOIN flights f ON s.trip_id = f.trip_id
    LEFT JOIN hotels h ON s.trip_id = h.trip_id
    WHERE s.session_start >= '2023-01-04'
    GROUP BY u.user_id
)
-- Use the master_data CTE to select the data
SELECT * FROM master_data;
"""

print('Result Query:')
display(pd.read_sql(sa.text(query), connection))

"""### Segmentation Implementation
1. RFM (Recency, Frequency, Monetary) Segmentation
"""

query = """
WITH master_data AS (
    SELECT
        u.user_id,
        COUNT(s.session_id) AS total_sessions,
        SUM(f.base_fare_usd + h.hotel_per_room_usd) AS total_spent,
        MAX(s.session_end) AS last_session_date
    FROM users u
    LEFT JOIN sessions s ON u.user_id = s.user_id
    LEFT JOIN flights f ON s.trip_id = f.trip_id
    LEFT JOIN hotels h ON s.trip_id = h.trip_id
    GROUP BY u.user_id
)
-- RFM segmentation
SELECT
    user_id,
    EXTRACT(day FROM (CURRENT_DATE - last_session_date)) AS recency_days,  -- Recency
    total_sessions AS frequency,                                         -- Frequency
    total_spent AS monetary,                                              -- Monetary
    CASE
        WHEN total_spent > 10000 THEN 'High Value'
        WHEN total_spent BETWEEN 5000 AND 10000 THEN 'Medium Value'
        ELSE 'Low Value'
    END AS value_segment
FROM master_data;
"""

print('Result Query:')
display(pd.read_sql(sa.text(query), connection))

"""### Analysis and Recommendations
With this combined segmentation, such as:

Targeted Email Campaigns: Personalize email content based on the value_segment, loyalty_segment, and booking_behavior_segment. For example, offer exclusive discounts to high-value, high-loyalty customers, or provide special last-minute deals to Last-Minute Bookers.
Retention Strategies: Focus retention efforts on customers in the High Churn Risk segment by offering special incentives or personalized offers to encourage continued engagement.
Promotion Sensitivity: Tailor promotions specifically for those identified as Promotion Sensitive, ensuring that the discounts or offers align with their booking patterns.
Loyalty Program: Develop loyalty tiers within the rewards program that align with the loyalty_segment and value_segment, offering more benefits to higher-tier customers.
This segmentation approach provides a robust foundation for TravelTide to improve customer retention, personalize marketing efforts, and enhance overall service quality.

## Defining the Cohort
Objective: Filter the customers to include only those who have enough data to provide meaningful insights.

Filter Criteria: Customers should have a certain number of sessions and should not have signed up recently (e.g., more than 30 days ago).
"""

query="""
SELECT u.*
FROM users u
JOIN (
    SELECT user_id, MAX(session_end) as max_session_end
    FROM sessions
    WHERE session_start >= '2023-01-04'
    GROUP BY user_id
    HAVING COUNT(session_id) >= 5 -- Filter for users with at least 5 sessions
) s ON u.user_id = s.user_id
WHERE u.sign_up_date <= s.max_session_end - INTERVAL '6 Months';
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""### Forming the Initial Extraction Query
Objective: Combine relevant data from sessions, flights, and hotels, and filter based on the cohort defined.

Steps:

Join Tables: Combine session, flight, and hotel data with the cohort defined.
"""

query="""SELECT u.user_id, u.sign_up_date, s.session_id, s.session_start, s.session_end, f.base_fare_usd, h.hotel_per_room_usd
FROM users u
JOIN sessions s ON u.user_id = s.user_id
LEFT JOIN flights f ON s.trip_id = f.trip_id
LEFT JOIN hotels h ON s.trip_id = h.trip_id
WHERE u.sign_up_date <= CURRENT_DATE - INTERVAL '30 days'
  AND u.user_id IN (
      SELECT user_id
      FROM sessions
      GROUP BY user_id
      HAVING COUNT(session_id) >= 5
  );
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""###User Spending and Activity Analysis
Cohort Filtering:
The query filters users who signed up at least 30 days ago and have engaged in at least five sessions. This ensures we are analyzing users who are active and have accumulated sufficient engagement data.
"""

query="""SELECT
    u.user_id,
    COUNT(s.session_id) AS total_sessions,
    SUM(f.base_fare_usd) AS total_flight_spent,
    SUM(h.hotel_per_room_usd) AS total_hotel_spent,
    SUM(f.base_fare_usd + h.hotel_per_room_usd) AS total_spent,
    AVG(DATE_PART('day', f.departure_time::timestamp - s.session_start::timestamp)) AS avg_booking_window_days
FROM users u
JOIN sessions s ON u.user_id = s.user_id
LEFT JOIN flights f ON s.trip_id = f.trip_id
LEFT JOIN hotels h ON s.trip_id = h.trip_id
WHERE u.sign_up_date <= CURRENT_DATE - INTERVAL '30 days'
  AND u.user_id IN (
      SELECT user_id
      FROM sessions
      GROUP BY user_id
      HAVING COUNT(session_id) >= 5
  )
GROUP BY u.user_id;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""###Forming the User Spending Distribution Query
Objective: Identify and analyze users whose total spending falls within a specific range based on interquartile range (IQR).

Cohort Filtering:
Only include users who signed up at least 30 days ago and have participated in at least five sessions to ensure the cohort consists of active users.
"""

query="""WITH stats AS (
    SELECT
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY total_spent) AS q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY total_spent) AS q3
    FROM (
        SELECT
            u.user_id,
            SUM(f.base_fare_usd + h.hotel_per_room_usd) AS total_spent
        FROM users u
        JOIN sessions s ON u.user_id = s.user_id
        LEFT JOIN flights f ON s.trip_id = f.trip_id
        LEFT JOIN hotels h ON s.trip_id = h.trip_id
       JOIN (SELECT user_id, MAX(session_end) as max_session_end FROM sessions GROUP BY user_id) as max_sessions ON u.user_id = max_sessions.user_id
            WHERE u.sign_up_date <= max_sessions.max_session_end - INTERVAL '30 days'
          AND u.user_id IN (
              SELECT user_id
              FROM sessions
              GROUP BY user_id
              HAVING COUNT(session_id) > 7
          )
        GROUP BY u.user_id
    ) AS subquery
),
data_with_iqr AS (
    SELECT
        *,
        q3 - q1 AS iqr
    FROM (
        SELECT
            user_id,
            total_spent
        FROM (
            SELECT
                u.user_id,
                SUM(f.base_fare_usd + h.hotel_per_room_usd) AS total_spent
            FROM users u
            JOIN sessions s ON u.user_id = s.user_id
            LEFT JOIN flights f ON s.trip_id = f.trip_id
            LEFT JOIN hotels h ON s.trip_id = h.trip_id
           JOIN (SELECT user_id, MAX(session_end) as max_session_end FROM sessions GROUP BY user_id) as max_sessions ON u.user_id = max_sessions.user_id
          WHERE u.sign_up_date <= max_sessions.max_session_end - INTERVAL '30 days'
              AND u.user_id IN (
                  SELECT user_id
                  FROM sessions
                  GROUP BY user_id
                  HAVING COUNT(session_id) > 7
              )
            GROUP BY u.user_id
        ) AS subquery
    ) AS data
    CROSS JOIN stats
)
SELECT *
FROM data_with_iqr
WHERE total_spent BETWEEN (q1 - 1.5 * iqr) AND (q3 + 1.5 * iqr);
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""###Forming the User Session Activity Query
Objective: Retrieve users who have had significant session activity within the last 6 months, based on their session data.

Cohort Filtering:
Only include users whose signup date is at least 6 months prior to their most recent session (max_session_end), ensuring the cohort consists of long-term, engaged users.
"""

query="""SELECT u.user_id, COUNT(s.session_id) AS total_sessions
FROM users u
JOIN sessions s ON u.user_id = s.user_id
JOIN (SELECT user_id, MAX(session_end) as max_session_end FROM sessions GROUP BY user_id) as max_sessions ON u.user_id = max_sessions.user_id
WHERE u.sign_up_date <= max_sessions.max_session_end - INTERVAL '6 months'
GROUP BY u.user_id
HAVING COUNT(s.session_id) >= 10
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""###Forming the User Travel and Activity Analysis Query
Objective: Analyze user behavior in terms of flights, hotel bookings, and session engagement for users who signed up within a specific timeframe.

Cohort Filtering:
The query filters users who signed up between January 1, 2022, and December 31, 2022, focusing on this specific cohort to understand their travel and activity patterns.
"""

query = """
SELECT u.user_id,
       COUNT(DISTINCT f.trip_id) AS total_flights,
       AVG(s.page_clicks) AS avg_page_clicks,
       SUM(f.base_fare_usd) AS total_flight_spend,
       SUM(h.nights) AS total_nights_stayed,
       COUNT(DISTINCT h.hotel_name) AS total_hotels_booked
FROM users u
JOIN sessions s ON u.user_id = s.user_id
LEFT JOIN flights f ON s.trip_id = f.trip_id
LEFT JOIN hotels h ON s.trip_id = h.trip_id
WHERE u.user_id IN (
    SELECT user_id
    FROM users
    WHERE sign_up_date BETWEEN '2022-01-01' AND '2022-12-31'
)
GROUP BY u.user_id
"""

print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""###Forming the Comprehensive User Travel and Engagement Query
Objective: Extract detailed user travel and session data for users who have demonstrated high engagement over a defined period.

Cohort Filtering:
The query first selects users who have had more than 7 distinct sessions starting between January 4, 2023, and the most recent session end date. This cohort ensures we're focusing on highly active users during the specified timeframe.
"""

query="""WITH cohort_users AS (
    SELECT u.user_id
    FROM users u
    JOIN sessions s ON u.user_id = s.user_id
    WHERE s.session_start BETWEEN '2023-01-04' AND (SELECT MAX(session_end) FROM sessions)
    GROUP BY u.user_id
    HAVING COUNT(DISTINCT s.session_id) > 7
)

SELECT
    u.user_id,
    COUNT(DISTINCT f.trip_id) AS total_flights,
    AVG(s.page_clicks) AS avg_page_clicks,
    SUM(f.base_fare_usd) AS total_flight_spend,
    SUM(h.nights) AS total_nights_stayed,
    COUNT(DISTINCT h.hotel_name) AS total_hotels_booked,
    SUM(f.checked_bags) AS total_checked_bags,  -- Total number of checked bags
    SUM(h.rooms) AS total_rooms_booked,         -- Total number of rooms booked
    AVG(s.flight_discount_amount) AS avg_flight_discount,  -- Average flight discount offered
    AVG(s.hotel_discount_amount) AS avg_hotel_discount,    -- Average hotel discount offered
    COUNT(DISTINCT s.session_id) AS total_sessions,        -- Total number of sessions per user
    AVG(h.hotel_per_room_usd * h.rooms * h.nights) AS avg_hotel_spend,  -- Average hotel spend per user
    SUM(h.hotel_per_room_usd * h.rooms * h.nights) AS total_hotel_spend  -- Total hotel spend per user
FROM
    cohort_users u
JOIN
    sessions s ON u.user_id = s.user_id
LEFT JOIN
    flights f ON s.trip_id = f.trip_id
LEFT JOIN
    hotels h ON s.trip_id = h.trip_id
GROUP BY
    u.user_id
ORDER BY
    total_flight_spend DESC;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""###Frequent Travelers
Cohort Definition: Customers who have booked a high number of flights or hotel stays.
Use Case: This cohort can help focus on customers who are frequent travelers and might be more likely to join a loyalty program.
"""

query="""WITH cohort_users AS (
    SELECT u.user_id
    FROM users u
    JOIN sessions s ON u.user_id = s.user_id
    LEFT JOIN flights f ON s.trip_id = f.trip_id
    LEFT JOIN hotels h ON s.trip_id = h.trip_id
    WHERE s.session_start BETWEEN '2023-01-04' AND (SELECT MAX(session_end) FROM sessions)
    GROUP BY u.user_id
    HAVING COUNT(DISTINCT f.trip_id) > 3 OR COUNT(DISTINCT h.trip_id) > 2
)

SELECT
    u.user_id,
    COUNT(DISTINCT f.trip_id) AS total_flights,
    AVG(s.page_clicks) AS avg_page_clicks,
    SUM(f.base_fare_usd) AS total_flight_spend,
    SUM(h.nights) AS total_nights_stayed,
    COUNT(DISTINCT h.hotel_name) AS total_hotels_booked,
    SUM(f.checked_bags) AS total_checked_bags,  -- Total number of checked bags
    SUM(h.rooms) AS total_rooms_booked,         -- Total number of rooms booked
    AVG(s.flight_discount_amount) AS avg_flight_discount,  -- Average flight discount offered
    AVG(s.hotel_discount_amount) AS avg_hotel_discount     -- Average hotel discount offered
FROM
    cohort_users u
JOIN
    sessions s ON u.user_id = s.user_id
LEFT JOIN
    flights f ON s.trip_id = f.trip_id
LEFT JOIN
    hotels h ON s.trip_id = h.trip_id
GROUP BY
    u.user_id
ORDER BY
    total_flight_spend DESC;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""### Identify Invalid Values

"""

query="""
SELECT *
FROM (SELECT hotel_name, nights FROM hotels) AS flight_booking
WHERE nights <= 0;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""### Remove Invalid Values


"""

query="""
WITH cohort_users AS (
    SELECT
        s.user_id
    FROM
        sessions s
    WHERE
        s.session_start >= '2023-01-04'
    GROUP BY
        s.user_id
    HAVING
        COUNT(s.session_id) > 7  -- Filtering users with more than 7 sessions
)

SELECT
    s.session_id,s.user_id,
    COUNT(DISTINCT f.trip_id) AS total_flights,
    AVG(s.page_clicks) AS avg_page_clicks,
    SUM(f.base_fare_usd) AS total_flight_spend,
    SUM(CASE WHEN h.nights < 1 THEN 1 ELSE h.nights END) AS total_nights_stayed,
    COUNT(DISTINCT h.hotel_name) AS total_hotels_booked,
    AVG(f.checked_bags) AS total_checked_bags,  -- Total number of checked bags
    SUM(h.rooms) AS total_rooms_booked,         -- Total number of rooms booked
    AVG(s.flight_discount_amount) AS avg_flight_discount,  -- Average flight discount offered
    AVG(s.hotel_discount_amount) AS avg_hotel_discount     -- Average hotel discount offered
FROM
    cohort_users cu
JOIN
    sessions s ON cu.user_id = s.user_id
LEFT JOIN
    flights f ON s.trip_id = f.trip_id
LEFT JOIN
    hotels h ON s.trip_id = h.trip_id
WHERE
    s.session_start >= '2023-01-04'
GROUP BY s.session_id,s.user_id
ORDER BY
 total_flight_spend DESC;
 """
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""###Forming the Detailed Session and Booking Data Query
Objective: Extract detailed session and booking data for users with significant activity in 2023, including their associated flights and hotel bookings.

Cohort Filtering:
The query identifies users who have had more than 7 sessions since January 4, 2023, by filtering through the sessions table. This cohort ensures that the focus is on users with sustained engagement throughout the year.
"""

query="""WITH sessions_2023 AS (

  SELECT *
  FROM sessions s
  WHERE s.session_start >= '2023-01-04'

),

filtered_users AS (

  SELECT user_id,
  			 COUNT(*)
  FROM sessions_2023 s
  GROUP BY user_id
  HAVING COUNT(*) > 7

),

session_base AS (

 SELECT
  		s.*,
 			u.*,
 			f.*,
 			h.hotel_name,
  		CASE
  			WHEN h.nights <= 0 THEN 1
  			ELSE h.nights
  		END AS nights,
  		h.rooms,
  		h.check_in_time,
  		h.check_out_time,
  		h.hotel_per_room_usd AS hotel_price_per_room_night_usd
  FROM sessions_2023 s

  LEFT JOIN users u
		ON s.user_id = u.user_id
	LEFT JOIN flights f
		ON s.trip_id = f.trip_id
	LEFT JOIN hotels h
		ON s.trip_id = h.trip_id

  WHERE s.user_id IN (SELECT user_id FROM filtered_users)

)

SELECT *
FROM session_base"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""Cohort Size Determination
This query identifies users who have participated in more than 7 sessions within the specified date range.
"""

query="""WITH cohort AS (
    SELECT
        s.user_id,
        COUNT(s.session_id) AS num_of_sessions
    FROM
        sessions s
    JOIN
        users u ON s.user_id = u.user_id
    WHERE
        s.session_start > '2023-01-04'

    GROUP BY
        s.user_id
    HAVING
        COUNT(s.session_id) > 7
)
SELECT
    COUNT(DISTINCT c.user_id) AS distinct_cohort_users
FROM
    cohort c
JOIN
    users u ON c.user_id = u.user_id;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""Listing Cohort Customers
This query lists all unique user IDs in the cohort.
"""

query="""WITH cohort AS (
    SELECT
        s.user_id,
        COUNT(s.session_id) AS num_of_sessions
    FROM
        sessions s
    JOIN
        users u ON s.user_id = u.user_id
    WHERE
        s.session_start > '2023-01-04'
    GROUP BY
        s.user_id
    HAVING
        COUNT(s.session_id) > 7
)
SELECT
    DISTINCT c.user_id AS distinct_cohort_users
FROM
    cohort c
JOIN
    users u ON c.user_id = u.user_id;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""##Comprehensive User Engagement and Perk Preference Analysis

Objective: Analyze user behavior and engagement metrics, scaling and aggregating them to identify users' preferences for travel discounts, flight bargains, and overall session activity. The final output ranks users based on these behaviors and recommends perks.

Cohort Filtering:
Users with more than 7 sessions since January 4, 2023, are selected, focusing on those with active recent engagement.

Step 1: Filter sessions in 2023 and users with more than 7 sessions

Step 2: Calculate flight-related metrics for filtered users

Step 3: Calculate browsing-related metrics for filtered users

Step 4:Combine flight and browsing metrics

Step 5: Scale the metrics using Min-Max Scaling

Step 6: Calculate the Bargain Hunter Index and additional indices

Step 7: Output the final metrics for each user
"""

query="""

WITH sessions_2023 AS (
  SELECT *
  FROM sessions s
  WHERE s.session_start >= '2023-01-04'
),

filtered_users AS (
  SELECT user_id,
         COUNT(*) AS session_count
  FROM sessions_2023
  GROUP BY user_id
  HAVING COUNT(*) > 7
),


flight_metrics AS (
  SELECT
    s.user_id,
    -- Metric 1: Proportion of flights booked with a discount
    SUM(CASE WHEN s.flight_discount = TRUE THEN 1 ELSE 0 END)::FLOAT / NULLIF(COUNT(s.trip_id), 0) AS discount_flight_proportion,

    -- Metric 2: Average flight discount amount (percentage)
    AVG(s.flight_discount_amount) AS average_flight_discount,

    -- Metric 3: ADS (Average Dollars Saved) per km traveled
    SUM(s.flight_discount_amount * f.base_fare_usd) / NULLIF(SUM(haversine_distance(u.home_airport_lat, u.home_airport_lon, f.destination_airport_lat, f.destination_airport_lon)), 0) AS ADS_per_km
  FROM sessions_2023 s
  LEFT JOIN flights f ON s.trip_id = f.trip_id
  JOIN users u ON s.user_id = u.user_id
  WHERE s.user_id IN (SELECT user_id FROM filtered_users)
  GROUP BY s.user_id
),


browsing_metrics AS (
  SELECT
    s.user_id,
    AVG(s.session_end - s.session_start) AS avg_session_time,
    SUM(s.page_clicks) AS total_page_clicks,
    AVG(CASE WHEN s.flight_booked = TRUE THEN 1.0 ELSE 0.0 END) AS conversion_rate
  FROM sessions_2023 s
  WHERE s.user_id IN (SELECT user_id FROM filtered_users)
  GROUP BY s.user_id
),


combined_metrics AS (
  SELECT
    COALESCE(fm.user_id, bm.user_id) AS user_id,
    COALESCE(fm.discount_flight_proportion, 0) AS discount_flight_proportion,
    COALESCE(fm.average_flight_discount, 0) AS avg_flight_discount,
    COALESCE(fm.ADS_per_km, 0) AS ADS_flight_per_km,
    COALESCE(bm.avg_session_time, INTERVAL '0 seconds') AS avg_session_time,
    COALESCE(bm.total_page_clicks, 0) AS total_page_clicks,
    COALESCE(bm.conversion_rate, 0) AS conversion_rate
  FROM flight_metrics fm
  FULL OUTER JOIN browsing_metrics bm ON fm.user_id = bm.user_id
),


scaled_metrics AS (
  SELECT
    user_id,
    CASE WHEN (MAX(discount_flight_proportion) OVER() - MIN(discount_flight_proportion) OVER()) != 0
         THEN (discount_flight_proportion - MIN(discount_flight_proportion) OVER()) / (MAX(discount_flight_proportion) OVER() - MIN(discount_flight_proportion) OVER())
         ELSE 0 END AS scaled_discount_flight_proportion,

    CASE WHEN (MAX(avg_flight_discount) OVER() - MIN(avg_flight_discount) OVER()) != 0
         THEN (avg_flight_discount - MIN(avg_flight_discount) OVER()) / (MAX(avg_flight_discount) OVER() - MIN(avg_flight_discount) OVER())
         ELSE 0 END AS scaled_avg_flight_discount,

    CASE WHEN (MAX(ADS_flight_per_km) OVER() - MIN(ADS_flight_per_km) OVER()) != 0
         THEN (ADS_flight_per_km - MIN(ADS_flight_per_km) OVER()) / (MAX(ADS_flight_per_km) OVER() - MIN(ADS_flight_per_km) OVER())
         ELSE 0 END AS scaled_ADS_flight_per_km,

    CASE WHEN (EXTRACT(EPOCH FROM MAX(avg_session_time) OVER()) - EXTRACT(EPOCH FROM MIN(avg_session_time) OVER())) != 0
         THEN EXTRACT(EPOCH FROM (avg_session_time - MIN(avg_session_time) OVER())) / (EXTRACT(EPOCH FROM MAX(avg_session_time) OVER()) - EXTRACT(EPOCH FROM MIN(avg_session_time) OVER()))
         ELSE 0 END AS scaled_avg_session_time,

    CASE WHEN (MAX(total_page_clicks) OVER() - MIN(total_page_clicks) OVER()) != 0
         THEN (total_page_clicks - MIN(total_page_clicks) OVER()) / (MAX(total_page_clicks) OVER() - MIN(total_page_clicks) OVER())
         ELSE 0 END AS scaled_total_page_clicks,

    CASE WHEN (MAX(conversion_rate) OVER() - MIN(conversion_rate) OVER()) != 0
         THEN (conversion_rate - MIN(conversion_rate) OVER()) / (MAX(conversion_rate) OVER() - MIN(conversion_rate) OVER())
         ELSE 0 END AS scaled_conversion_rate
  FROM combined_metrics
),


final_metrics AS (
  SELECT
    user_id,
    -- Bargain Hunter Index
    (scaled_discount_flight_proportion * scaled_avg_flight_discount * scaled_ADS_flight_per_km) AS bargain_hunter_index,
    -- Flight Index
    (scaled_discount_flight_proportion + scaled_avg_flight_discount + scaled_ADS_flight_per_km) AS flight_index,
    -- Browsing Index
    (scaled_avg_session_time + scaled_total_page_clicks + scaled_conversion_rate) AS browsing_index
  FROM scaled_metrics
)


SELECT *
FROM final_metrics;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

query="""WITH sessions_2023 AS (
  SELECT *
  FROM sessions s
  WHERE s.session_start >= '2023-01-04'
),

filtered_users AS (
  SELECT
    user_id,
    COUNT(*) AS session_count
  FROM sessions_2023
  GROUP BY user_id
  HAVING COUNT(*) > 7
),

flight_metrics AS (
  SELECT
    s.user_id,
    -- Proportion of flights booked with a discount
    SUM(CASE WHEN s.flight_discount = TRUE THEN 1 ELSE 0 END)::FLOAT / NULLIF(COUNT(s.trip_id), 0) AS discount_flight_proportion,

    -- Average flight discount amount (percentage)
    AVG(s.flight_discount_amount) AS average_flight_discount,

    -- Average Dollars Saved per km traveled
    SUM(s.flight_discount_amount * f.base_fare_usd) / NULLIF(SUM(haversine_distance(u.home_airport_lat, u.home_airport_lon, f.destination_airport_lat, f.destination_airport_lon)), 0) AS ADS_per_km
  FROM sessions_2023 s
  LEFT JOIN flights f ON s.trip_id = f.trip_id
  JOIN users u ON s.user_id = u.user_id
  WHERE s.user_id IN (SELECT user_id FROM filtered_users)
  GROUP BY s.user_id
),

browsing_metrics AS (
  SELECT
    s.user_id,
    AVG(s.session_end - s.session_start) AS avg_session_time,
    SUM(s.page_clicks) AS total_page_clicks,
    AVG(CASE WHEN s.flight_booked = TRUE THEN 1.0 ELSE 0.0 END) AS conversion_rate
  FROM sessions_2023 s
  WHERE s.user_id IN (SELECT user_id FROM filtered_users)
  GROUP BY s.user_id
),

combined_metrics AS (
  SELECT
    COALESCE(fm.user_id, bm.user_id) AS user_id,
    COALESCE(fm.discount_flight_proportion, 0) AS discount_flight_proportion,
    COALESCE(fm.average_flight_discount, 0) AS avg_flight_discount,
    COALESCE(fm.ADS_per_km, 0) AS ADS_flight_per_km,
    COALESCE(bm.avg_session_time, INTERVAL '0 seconds') AS avg_session_time,
    COALESCE(bm.total_page_clicks, 0) AS total_page_clicks,
    COALESCE(bm.conversion_rate, 0) AS conversion_rate
  FROM flight_metrics fm
  FULL OUTER JOIN browsing_metrics bm ON fm.user_id = bm.user_id
),

scaled_metrics AS (
  SELECT
    user_id,
    CASE WHEN (MAX(discount_flight_proportion) OVER() - MIN(discount_flight_proportion) OVER()) != 0
         THEN (discount_flight_proportion - MIN(discount_flight_proportion) OVER()) / (MAX(discount_flight_proportion) OVER() - MIN(discount_flight_proportion) OVER())
         ELSE 0 END AS scaled_discount_flight_proportion,

    CASE WHEN (MAX(avg_flight_discount) OVER() - MIN(avg_flight_discount) OVER()) != 0
         THEN (avg_flight_discount - MIN(avg_flight_discount) OVER()) / (MAX(avg_flight_discount) OVER() - MIN(avg_flight_discount) OVER())
         ELSE 0 END AS scaled_avg_flight_discount,

    CASE WHEN (MAX(ADS_flight_per_km) OVER() - MIN(ADS_flight_per_km) OVER()) != 0
         THEN (ADS_flight_per_km - MIN(ADS_flight_per_km) OVER()) / (MAX(ADS_flight_per_km) OVER() - MIN(ADS_flight_per_km) OVER())
         ELSE 0 END AS scaled_ADS_flight_per_km,

    CASE WHEN (EXTRACT(EPOCH FROM MAX(avg_session_time) OVER()) - EXTRACT(EPOCH FROM MIN(avg_session_time) OVER())) != 0
         THEN EXTRACT(EPOCH FROM (avg_session_time - MIN(avg_session_time) OVER())) / (EXTRACT(EPOCH FROM MAX(avg_session_time) OVER()) - EXTRACT(EPOCH FROM MIN(avg_session_time) OVER()))
         ELSE 0 END AS scaled_avg_session_time,

    CASE WHEN (MAX(total_page_clicks) OVER() - MIN(total_page_clicks) OVER()) != 0
         THEN (total_page_clicks - MIN(total_page_clicks) OVER()) / (MAX(total_page_clicks) OVER() - MIN(total_page_clicks) OVER())
         ELSE 0 END AS scaled_total_page_clicks,

    CASE WHEN (MAX(conversion_rate) OVER() - MIN(conversion_rate) OVER()) != 0
         THEN (conversion_rate - MIN(conversion_rate) OVER()) / (MAX(conversion_rate) OVER() - MIN(conversion_rate) OVER())
         ELSE 0 END AS scaled_conversion_rate
  FROM combined_metrics
),

final_metrics AS (
  SELECT
    sm.user_id,
    -- Bargain Hunter Index
    (sm.scaled_discount_flight_proportion * sm.scaled_avg_flight_discount * sm.scaled_ADS_flight_per_km) AS bargain_hunter_index,
    -- Flight Index
    (sm.scaled_discount_flight_proportion + sm.scaled_avg_flight_discount + sm.scaled_ADS_flight_per_km) AS flight_index,
    -- Browsing Index
    (sm.scaled_avg_session_time + sm.scaled_total_page_clicks + sm.scaled_conversion_rate) AS browsing_index
  FROM scaled_metrics sm
),

perks_summary AS (
  SELECT
    s.user_id,
    SUM(CASE WHEN s.cancellation = 'true' THEN 1 ELSE 0 END) AS cancellation_pref,
    SUM(CASE WHEN s.flight_discount = 'true' AND s.cancellation = 'false' AND s.flight_booked = 'true' THEN 1 ELSE 0 END) AS flight_discount_pref,
    SUM(CASE WHEN s.hotel_discount = 'true' AND s.cancellation = 'false' AND s.hotel_booked = 'true' THEN 1 ELSE 0 END) AS hotel_discount_pref,
    SUM(CASE WHEN s.flight_booked = 'true' THEN 1 ELSE 0 END) as total_flight_booked,
    SUM(CASE WHEN s.hotel_booked = 'true' THEN 1 ELSE 0 END) as total_hotel_booked
  FROM sessions_2023 s
  WHERE s.user_id IN (SELECT user_id FROM filtered_users)
  GROUP BY s.user_id
),

combined_final AS (
  SELECT
    fm.user_id,
    fm.bargain_hunter_index,
    fm.flight_index,
    fm.browsing_index,
    ps.cancellation_pref,
    ps.flight_discount_pref,
    ps.hotel_discount_pref,
    CASE
        WHEN (ps.cancellation_pref > 2) THEN 'Free Cancellation'
        WHEN ps.flight_discount_pref > ps.hotel_discount_pref THEN 'Flight Discount'
        ELSE 'Hotel Discount'
    END AS preferred_perk
  FROM final_metrics fm
  LEFT JOIN perks_summary ps ON fm.user_id = ps.user_id
)

-- Output the final metrics for each user along with the recommended perk
SELECT *
FROM combined_final
ORDER BY bargain_hunter_index DESC, flight_index DESC, browsing_index DESC;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

query="""WITH sessions_2023 AS (
  SELECT *
  FROM sessions s
  WHERE s.session_start >= '2023-01-04'
),

filtered_users AS (
  SELECT
    user_id,
    COUNT(*) AS session_count
  FROM sessions_2023
  GROUP BY user_id
  HAVING COUNT(*) > 7
),

flight_metrics AS (
  SELECT
    s.user_id,

    SUM(CASE WHEN s.flight_discount = TRUE THEN 1 ELSE 0 END)::FLOAT / NULLIF(COUNT(s.trip_id), 0) AS discount_flight_proportion,


    AVG(s.flight_discount_amount) AS average_flight_discount,


    SUM(s.flight_discount_amount * f.base_fare_usd) / NULLIF(SUM(haversine_distance(u.home_airport_lat, u.home_airport_lon, f.destination_airport_lat, f.destination_airport_lon)), 0) AS ADS_per_km,


    AVG(f.checked_bags) AS avg_checked_bags,


    SUM(CASE WHEN f.checked_bags > 0 THEN 1 ELSE 0 END) AS total_free_checked_bag,


    SUM(haversine_distance(u.home_airport_lat, u.home_airport_lon, f.destination_airport_lat, f.destination_airport_lon)) AS total_distance_traveled,


    SUM(CASE WHEN s.flight_discount = TRUE THEN 1 ELSE 0 END) AS total_discounted_trips,


    SUM(CASE WHEN s.flight_booked = TRUE THEN 1 ELSE 0 END) AS total_flight_booked
  FROM sessions_2023 s
  LEFT JOIN flights f ON s.trip_id = f.trip_id
  JOIN users u ON s.user_id = u.user_id
  WHERE s.user_id IN (SELECT user_id FROM filtered_users)
  GROUP BY s.user_id
),

browsing_metrics AS (
  SELECT
    s.user_id,
    AVG(s.session_end - s.session_start) AS avg_session_time,
    SUM(s.page_clicks) AS total_page_clicks,
    AVG(CASE WHEN s.flight_booked = TRUE THEN 1.0 ELSE 0.0 END) AS conversion_rate
  FROM sessions_2023 s
  WHERE s.user_id IN (SELECT user_id FROM filtered_users)
  GROUP BY s.user_id
),

hotel_metrics AS (
  SELECT
    s.user_id,
    SUM(h.nights * h.rooms * h.hotel_per_room_usd) AS total_hotel_spending,
    AVG(h.nights * h.hotel_per_room_usd) AS avg_cost_per_night,
    AVG(h.rooms) AS avg_rooms_booked,
    SUM(h.nights) AS total_nights
  FROM sessions_2023 s
  LEFT JOIN hotels h ON s.trip_id = h.trip_id
  WHERE s.user_id IN (SELECT user_id FROM filtered_users)
  GROUP BY s.user_id
),

perks_summary AS (
  SELECT
    s.user_id,
    SUM(CASE WHEN s.cancellation = 'true' THEN 1 ELSE 0 END) AS cancellation_pref,
    SUM(CASE WHEN s.flight_discount = 'true' AND s.cancellation = 'false' AND s.flight_booked = 'true' THEN 1 ELSE 0 END) AS flight_discount_pref,
    SUM(CASE WHEN s.hotel_discount = 'true' AND s.cancellation = 'false' AND s.hotel_booked = 'true' THEN 1 ELSE 0 END) AS hotel_discount_pref,
    AVG(hm.avg_cost_per_night) AS avg_cost_per_night,
    AVG(hm.avg_rooms_booked) AS avg_rooms_booked,
    SUM(fm.total_free_checked_bag) AS total_free_checked_bag,
    SUM(fm.total_distance_traveled) AS total_distance_traveled,
    SUM(fm.total_discounted_trips) AS total_discounted_trips,
    SUM(fm.total_distance_traveled) / NULLIF(SUM(fm.total_discounted_trips), 0) AS avg_distance_per_trip,
    SUM(fm.total_distance_traveled) / NULLIF(SUM(fm.total_discounted_trips), 0) > 2000 AS is_frequent_traveler,
    SUM(fm.total_discounted_trips)::FLOAT / NULLIF(SUM(fm.total_flight_booked), 0) > 0.55 AS is_discount_lover-- using total hotel ,is discount lovers
  FROM sessions_2023 s
  LEFT JOIN flight_metrics fm ON s.user_id = fm.user_id
  LEFT JOIN hotel_metrics hm ON s.user_id = hm.user_id
  WHERE s.user_id IN (SELECT user_id FROM filtered_users)
  GROUP BY s.user_id
),

combined_metrics AS (
  SELECT
    COALESCE(fm.user_id, bm.user_id) AS user_id,
    COALESCE(fm.discount_flight_proportion, 0) AS discount_flight_proportion,
    COALESCE(fm.average_flight_discount, 0) AS avg_flight_discount,
    COALESCE(fm.ADS_per_km, 0) AS ADS_flight_per_km,
    COALESCE(fm.avg_checked_bags, 0) AS avg_checked_bags,
    COALESCE(fm.total_free_checked_bag, 0) AS total_free_checked_bag,
    COALESCE(bm.avg_session_time, INTERVAL '0 seconds') AS avg_session_time,
    COALESCE(bm.total_page_clicks, 0) AS total_page_clicks,
    COALESCE(bm.conversion_rate, 0) AS conversion_rate,
    COALESCE(hm.total_hotel_spending, 0) AS total_hotel_spending,
    COALESCE(hm.avg_cost_per_night, 0) AS avg_cost_per_night,
    COALESCE(hm.avg_rooms_booked, 0) AS avg_rooms_booked,
    COALESCE(ps.total_distance_traveled, 0) AS total_distance_traveled,
    COALESCE(ps.total_discounted_trips, 0) AS total_discounted_trips
  FROM flight_metrics fm
  FULL OUTER JOIN browsing_metrics bm ON fm.user_id = bm.user_id
  FULL OUTER JOIN hotel_metrics hm ON fm.user_id = hm.user_id
  LEFT JOIN perks_summary ps ON fm.user_id = ps.user_id
),
scaled_metrics AS (
  SELECT
    user_id,
    -- Scaling the metrics
    CASE WHEN (MAX(discount_flight_proportion) OVER() - MIN(discount_flight_proportion) OVER()) != 0
         THEN (discount_flight_proportion - MIN(discount_flight_proportion) OVER()) / (MAX(discount_flight_proportion) OVER() - MIN(discount_flight_proportion) OVER())
         ELSE 0 END AS scaled_discount_flight_proportion,

    CASE WHEN (MAX(avg_flight_discount) OVER() - MIN(avg_flight_discount) OVER()) != 0
         THEN (avg_flight_discount - MIN(avg_flight_discount) OVER()) / (MAX(avg_flight_discount) OVER() - MIN(avg_flight_discount) OVER())
         ELSE 0 END AS scaled_avg_flight_discount,

    CASE WHEN (MAX(ADS_flight_per_km) OVER() - MIN(ADS_flight_per_km) OVER()) != 0
         THEN (ADS_flight_per_km - MIN(ADS_flight_per_km) OVER()) / (MAX(ADS_flight_per_km) OVER() - MIN(ADS_flight_per_km) OVER())
         ELSE 0 END AS scaled_ADS_flight_per_km,

    CASE WHEN (MAX(avg_checked_bags) OVER() - MIN(avg_checked_bags) OVER()) != 0
         THEN (avg_checked_bags - MIN(avg_checked_bags) OVER()) / (MAX(avg_checked_bags) OVER() - MIN(avg_checked_bags) OVER())
         ELSE 0 END AS scaled_avg_checked_bags,

    CASE WHEN (MAX(total_free_checked_bag) OVER() - MIN(total_free_checked_bag) OVER()) != 0
         THEN (total_free_checked_bag - MIN(total_free_checked_bag) OVER()) / (MAX(total_free_checked_bag) OVER() - MIN(total_free_checked_bag) OVER())
         ELSE 0 END AS scaled_total_free_checked_bag,

    CASE WHEN (MAX(avg_cost_per_night) OVER() - MIN(avg_cost_per_night) OVER()) != 0
         THEN (avg_cost_per_night - MIN(avg_cost_per_night) OVER()) / (MAX(avg_cost_per_night) OVER() - MIN(avg_cost_per_night) OVER())
         ELSE 0 END AS scaled_avg_cost_per_night,

    CASE WHEN (MAX(avg_rooms_booked) OVER() - MIN(avg_rooms_booked) OVER()) != 0
         THEN (avg_rooms_booked - MIN(avg_rooms_booked) OVER()) / (MAX(avg_rooms_booked) OVER() - MIN(avg_rooms_booked) OVER())
         ELSE 0 END AS scaled_avg_rooms_booked,

    CASE WHEN (EXTRACT(EPOCH FROM MAX(avg_session_time) OVER()) - EXTRACT(EPOCH FROM MIN(avg_session_time) OVER())) != 0
         THEN EXTRACT(EPOCH FROM (avg_session_time - MIN(avg_session_time) OVER())) / (EXTRACT(EPOCH FROM MAX(avg_session_time) OVER()) - EXTRACT(EPOCH FROM MIN(avg_session_time) OVER()))
         ELSE 0 END AS scaled_avg_session_time,

    CASE WHEN (MAX(total_page_clicks) OVER() - MIN(total_page_clicks) OVER()) != 0
         THEN (total_page_clicks - MIN(total_page_clicks) OVER()) / (MAX(total_page_clicks) OVER() - MIN(total_page_clicks) OVER())
         ELSE 0 END AS scaled_total_page_clicks,

    CASE WHEN (MAX(conversion_rate) OVER() - MIN(conversion_rate) OVER()) != 0
         THEN (conversion_rate - MIN(conversion_rate) OVER()) / (MAX(conversion_rate) OVER() - MIN(conversion_rate) OVER())
         ELSE 0 END AS scaled_conversion_rate
  FROM combined_metrics
),

final_metrics AS (
  SELECT
    sm.user_id,
    -- Bargain Hunter Index
    (sm.scaled_discount_flight_proportion * sm.scaled_avg_flight_discount * sm.scaled_ADS_flight_per_km) AS bargain_hunter_index,
    -- Flight Index
    (sm.scaled_discount_flight_proportion + sm.scaled_avg_flight_discount + sm.scaled_ADS_flight_per_km + sm.scaled_avg_checked_bags) AS flight_index,
    -- Browsing Index
    (sm.scaled_avg_session_time + sm.scaled_total_page_clicks + sm.scaled_conversion_rate) AS browsing_index,
    -- Hotel Index
    (sm.scaled_avg_cost_per_night + sm.scaled_avg_rooms_booked) AS hotel_index
  FROM scaled_metrics sm
),

combined_final AS (
  SELECT
    fm.user_id,
    fm.bargain_hunter_index,
    fm.flight_index,
    fm.browsing_index,
    fm.hotel_index,
    ps.cancellation_pref,
    ps.flight_discount_pref,
    ps.hotel_discount_pref,
    ps.avg_cost_per_night,
    ps.avg_rooms_booked,
    ps.total_free_checked_bag,
    ps.is_frequent_traveler,
    ps.is_discount_lover,
    CASE
        WHEN ps.is_frequent_traveler THEN 'Free Hotel Night with Flight'
        WHEN ps.is_discount_lover THEN 'Exclusive Discount'
        WHEN ps.cancellation_pref >= 2 THEN 'Free Cancellation'
        WHEN ps.flight_discount_pref > ps.hotel_discount_pref THEN 'Flight Discount'
        WHEN ps.total_free_checked_bag > 0 THEN 'Free Checked Bags'
        WHEN ps.avg_cost_per_night < 100 THEN 'Budget Hotel'
        ELSE 'Luxury Hotel'
    END AS preferred_perk
  FROM final_metrics fm
  LEFT JOIN perks_summary ps ON fm.user_id = ps.user_id
)

-- Output the final metrics for each user along with the recommended perk
SELECT *
FROM combined_final

ORDER BY bargain_hunter_index DESC, flight_index DESC, browsing_index DESC, hotel_index DESC;

"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))

"""we calculates a detailed set of metrics and classifications for users based on their session, flight, and hotel data. It combines metrics like flight discounts, checked bags, session times, and hotel spending to classify users into different categories such as "Bargain Hunter," "Luxury Traveler," or "Family Traveler."

It also recommends perks based on behaviors such as frequent travel or preferences for hotel or flight discounts.

This query outputs a detailed user profile that includes both behavioral metrics and demographic details, classifying users into segments and providing personalized perk recommendations.
"""

query="""WITH sessions_2023 AS (
  SELECT *
  FROM sessions s
  WHERE s.session_start >= '2023-01-04'
),

filtered_users AS (
  SELECT
    user_id,
    COUNT(*) AS session_count
  FROM sessions_2023
  GROUP BY user_id
  HAVING COUNT(*) > 7
),

flight_metrics AS (
  SELECT
    s.user_id,
    -- Ratio of flights booked with discount
    SUM(CASE WHEN s.flight_discount = TRUE THEN 1 ELSE 0 END)::FLOAT / NULLIF(COUNT(s.trip_id), 0) AS discount_flight_proportion,

    -- Average flight discount amount
    AVG(s.flight_discount_amount) AS average_flight_discount,

    -- Average dollars saved per kilometer
    SUM(s.flight_discount_amount * f.base_fare_usd) / NULLIF(SUM(haversine_distance(u.home_airport_lat, u.home_airport_lon, f.destination_airport_lat, f.destination_airport_lon)), 0) AS ADS_per_km,

    -- Average number of checked bags
    AVG(f.checked_bags) AS avg_checked_bags,

    -- Total free checked bags
    SUM(CASE WHEN f.checked_bags > 0 THEN 1 ELSE 0 END) AS total_free_checked_bag,

    -- Total distance traveled
    SUM(haversine_distance(u.home_airport_lat, u.home_airport_lon, f.destination_airport_lat, f.destination_airport_lon)) AS total_distance_traveled,

    -- Total discounted trips
    SUM(CASE WHEN s.flight_discount = TRUE THEN 1 ELSE 0 END) AS total_discounted_trips,

    -- Total flights booked
    SUM(CASE WHEN s.flight_booked = TRUE THEN 1 ELSE 0 END) AS total_flight_booked
  FROM sessions_2023 s
  LEFT JOIN flights f ON s.trip_id = f.trip_id
  JOIN users u ON s.user_id = u.user_id
  WHERE s.user_id IN (SELECT user_id FROM filtered_users)
  GROUP BY s.user_id
),

browsing_metrics AS (
  SELECT
    s.user_id,
    AVG(s.session_end - s.session_start) AS avg_session_time,
    SUM(s.page_clicks) AS total_page_clicks,
    AVG(CASE WHEN s.flight_booked = TRUE THEN 1.0 ELSE 0.0 END) AS conversion_rate
  FROM sessions_2023 s
  WHERE s.user_id IN (SELECT user_id FROM filtered_users)
  GROUP BY s.user_id
),

hotel_metrics AS (
  SELECT
    s.user_id,
    SUM((CASE WHEN h.nights <= 0 THEN 1 ELSE h.nights END) * h.rooms * h.hotel_per_room_usd) AS total_hotel_spending,
    AVG((CASE WHEN h.nights <= 0 THEN 1 ELSE h.nights END) * h.hotel_per_room_usd) AS avg_cost_per_night,
    AVG(h.rooms) AS avg_rooms_booked,
    SUM(CASE WHEN h.nights <= 0 THEN 1 ELSE h.nights END) AS total_nights
  FROM sessions_2023 s
  LEFT JOIN hotels h ON s.trip_id = h.trip_id
  WHERE s.user_id IN (SELECT user_id FROM filtered_users)
  GROUP BY s.user_id
),


perks_summary AS (
  SELECT
    s.user_id,
    SUM(CASE WHEN s.cancellation = 'true' THEN 1 ELSE 0 END) AS cancellation_pref,
    SUM(CASE WHEN s.flight_discount = 'true' AND s.cancellation = 'false' AND s.flight_booked = 'true' THEN 1 ELSE 0 END) AS flight_discount_pref,
    SUM(CASE WHEN s.hotel_discount = 'true' AND s.cancellation = 'false' AND s.hotel_booked = 'true' THEN 1 ELSE 0 END) AS hotel_discount_pref,
    AVG(hm.avg_cost_per_night) AS avg_cost_per_night,
    AVG(hm.avg_rooms_booked) AS avg_rooms_booked,
    SUM(fm.total_free_checked_bag) AS total_free_checked_bag,
    SUM(fm.total_distance_traveled) AS total_distance_traveled,
    SUM(fm.total_discounted_trips) AS total_discounted_trips,
    SUM(fm.total_distance_traveled) / NULLIF(SUM(fm.total_discounted_trips), 0) AS avg_distance_per_trip,
    SUM(fm.total_distance_traveled) / NULLIF(SUM(fm.total_discounted_trips), 0) > 2000 AS is_frequent_traveler,
    AVG(CASE WHEN s.flight_discount = 'true' THEN 1.0 ELSE 0.0 END) > 0.5 AS is_flight_discount_lover,
    AVG(CASE WHEN s.hotel_discount = 'true' THEN 1.0 ELSE 0.0 END) > 0.5 AS is_hotel_discount_lover
  FROM sessions_2023 s
  LEFT JOIN flight_metrics fm ON s.user_id = fm.user_id
  LEFT JOIN hotel_metrics hm ON s.user_id = hm.user_id
  WHERE s.user_id IN (SELECT user_id FROM filtered_users)
  GROUP BY s.user_id
),


combined_metrics AS (
  SELECT
    COALESCE(fm.user_id, bm.user_id) AS user_id,
    COALESCE(fm.discount_flight_proportion, 0) AS discount_flight_proportion,
    COALESCE(fm.average_flight_discount, 0) AS avg_flight_discount,
    COALESCE(fm.ADS_per_km, 0) AS ADS_flight_per_km,
    COALESCE(fm.avg_checked_bags, 0) AS avg_checked_bags,
    COALESCE(fm.total_free_checked_bag, 0) AS total_free_checked_bag,
    COALESCE(bm.avg_session_time, INTERVAL '0 seconds') AS avg_session_time,
    COALESCE(bm.total_page_clicks, 0) AS total_page_clicks,
    COALESCE(bm.conversion_rate, 0) AS conversion_rate,
    COALESCE(hm.total_hotel_spending, 0) AS total_hotel_spending,
    COALESCE(hm.avg_cost_per_night, 0) AS avg_cost_per_night,
    COALESCE(hm.avg_rooms_booked, 0) AS avg_rooms_booked,
    COALESCE(ps.total_distance_traveled, 0) AS total_distance_traveled,
    COALESCE(ps.total_discounted_trips, 0) AS total_discounted_trips
  FROM flight_metrics fm
  FULL OUTER JOIN browsing_metrics bm ON fm.user_id = bm.user_id
  FULL OUTER JOIN hotel_metrics hm ON fm.user_id = hm.user_id
  LEFT JOIN perks_summary ps ON fm.user_id = ps.user_id
),

scaled_metrics AS (
  SELECT
    user_id,
    discount_flight_proportion, -- Ensure this column is included
    CASE WHEN (MAX(discount_flight_proportion) OVER() - MIN(discount_flight_proportion) OVER()) != 0
         THEN (discount_flight_proportion - MIN(discount_flight_proportion) OVER()) / (MAX(discount_flight_proportion) OVER() - MIN(discount_flight_proportion) OVER())
         ELSE 0 END AS scaled_discount_flight_proportion,

    CASE WHEN (MAX(avg_flight_discount) OVER() - MIN(avg_flight_discount) OVER()) != 0
         THEN (avg_flight_discount - MIN(avg_flight_discount) OVER()) / (MAX(avg_flight_discount) OVER() - MIN(avg_flight_discount) OVER())
         ELSE 0 END AS scaled_avg_flight_discount,

    CASE WHEN (MAX(ADS_flight_per_km) OVER() - MIN(ADS_flight_per_km) OVER()) != 0
         THEN (ADS_flight_per_km - MIN(ADS_flight_per_km) OVER()) / (MAX(ADS_flight_per_km) OVER() - MIN(ADS_flight_per_km) OVER())
         ELSE 0 END AS scaled_ADS_flight_per_km,

    CASE WHEN (MAX(avg_checked_bags) OVER() - MIN(avg_checked_bags) OVER()) != 0
         THEN (avg_checked_bags - MIN(avg_checked_bags) OVER()) / (MAX(avg_checked_bags) OVER() - MIN(avg_checked_bags) OVER())
         ELSE 0 END AS scaled_avg_checked_bags,

    CASE WHEN (MAX(total_free_checked_bag) OVER() - MIN(total_free_checked_bag) OVER()) != 0
         THEN (total_free_checked_bag - MIN(total_free_checked_bag) OVER()) / (MAX(total_free_checked_bag) OVER() - MIN(total_free_checked_bag) OVER())
         ELSE 0 END AS scaled_total_free_checked_bag,

    CASE WHEN (MAX(avg_cost_per_night) OVER() - MIN(avg_cost_per_night) OVER()) != 0
         THEN (avg_cost_per_night - MIN(avg_cost_per_night) OVER()) / (MAX(avg_cost_per_night) OVER() - MIN(avg_cost_per_night) OVER())
         ELSE 0 END AS scaled_avg_cost_per_night,

    CASE WHEN (MAX(avg_rooms_booked) OVER() - MIN(avg_rooms_booked) OVER()) != 0
         THEN (avg_rooms_booked - MIN(avg_rooms_booked) OVER()) / (MAX(avg_rooms_booked) OVER() - MIN(avg_rooms_booked) OVER())
         ELSE 0 END AS scaled_avg_rooms_booked,

    CASE WHEN EXTRACT(EPOCH FROM (MAX(avg_session_time) OVER() - MIN(avg_session_time) OVER())) != 0
         THEN (EXTRACT(EPOCH FROM avg_session_time) - EXTRACT(EPOCH FROM MIN(avg_session_time) OVER())) / EXTRACT(EPOCH FROM (MAX(avg_session_time) OVER() - MIN(avg_session_time) OVER()))
         ELSE 0 END AS scaled_avg_session_time,

    CASE WHEN (MAX(total_page_clicks) OVER() - MIN(total_page_clicks) OVER()) != 0
         THEN (total_page_clicks - MIN(total_page_clicks) OVER()) / (MAX(total_page_clicks) OVER() - MIN(total_page_clicks) OVER())
         ELSE 0 END AS scaled_total_page_clicks,

    CASE WHEN (MAX(conversion_rate) OVER() - MIN(conversion_rate) OVER()) != 0
         THEN (conversion_rate - MIN(conversion_rate) OVER()) / (MAX(conversion_rate) OVER() - MIN(conversion_rate) OVER())
         ELSE 0 END AS scaled_conversion_rate
  FROM combined_metrics
),

final_metrics AS (
  SELECT
    sm.user_id,
    -- Bargain Hunter Index
    (sm.scaled_discount_flight_proportion * sm.scaled_avg_flight_discount * sm.scaled_ADS_flight_per_km) AS bargain_hunter_index,
    -- Flight Index
    (sm.scaled_discount_flight_proportion + sm.scaled_avg_flight_discount + sm.scaled_ADS_flight_per_km + sm.scaled_avg_checked_bags) AS flight_index,
    -- Browsing Index
    (sm.scaled_avg_session_time + sm.scaled_total_page_clicks + sm.scaled_conversion_rate) AS browsing_index,
    -- Hotel Index
    (sm.scaled_avg_cost_per_night + sm.scaled_avg_rooms_booked) AS hotel_index
  FROM scaled_metrics sm
),

combined_final AS (
  SELECT
    fm.user_id,
    fm.bargain_hunter_index,
    fm.flight_index,
    fm.browsing_index,
    fm.hotel_index,
    cm.discount_flight_proportion,
    hm.total_hotel_spending,
    ps.cancellation_pref,
    ps.flight_discount_pref,
    ps.hotel_discount_pref,
    ps.avg_cost_per_night,
    ps.avg_rooms_booked,
    ps.total_free_checked_bag,
    ps.is_frequent_traveler,
    ps.is_flight_discount_lover,
    ps.is_hotel_discount_lover,
    CASE
        WHEN ps.cancellation_pref > 0 THEN 'Free Cancellation'
        WHEN ps.is_frequent_traveler THEN 'Free Hotel Night with Flight'
        WHEN ps.is_flight_discount_lover THEN 'Exclusive Flight Discount'
        WHEN ps.is_hotel_discount_lover THEN 'Exclusive Hotel Discount'
        WHEN ps.flight_discount_pref > ps.hotel_discount_pref THEN 'Flight Discount'
        WHEN ps.total_free_checked_bag > 0 THEN 'Free Checked Bags'
        WHEN ps.avg_cost_per_night < 100 THEN 'Budget Hotel'
        ELSE 'Luxury Hotel'
    END AS preferred_perk,

    -- Adjusted User Group Classification
    CASE
        WHEN hm.total_hotel_spending > 5000 THEN 'Luxury Traveler'
        WHEN fm.bargain_hunter_index > 1.5 THEN 'Bargain Hunter'
        WHEN ps.is_frequent_traveler THEN 'Frequent Traveler'
        WHEN ps.is_flight_discount_lover THEN 'Flight Discount Lover'
        WHEN ps.is_hotel_discount_lover THEN 'Hotel Discount Lover'
        ELSE 'Casual Traveler'
    END AS user_group_classification
  FROM final_metrics fm
  LEFT JOIN hotel_metrics hm ON fm.user_id = hm.user_id
  LEFT JOIN perks_summary ps ON fm.user_id = ps.user_id
  LEFT JOIN combined_metrics cm ON fm.user_id = cm.user_id
)

SELECT * FROM combined_final;
"""
print('Result Query :')
display(pd.read_sql(sa.text(query),connection))